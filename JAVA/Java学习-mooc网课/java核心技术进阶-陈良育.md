#### Java 构建工具
1. 自动帮程序员甄别和下载第三方库
2. 完成整个项目编译 调用 javac.exe
3. 完成整个项目单元测试流程 调用Junit
4. 完成项目打包
5. 等

当前主要的Java构建工具
> Maven, Gradle, Ivy, Builder, Ant

---
### 单元测试和JUnit

软件测试: 
>在规定条件下对程序进行操作,以发现错误,衡量软件质量.并对其是否满足设计要求进行评估的过程.

软件测试分类:
1. 单元 vs 集成测试
2. 白盒 vs 黑盒测试
3. 自动 vs 手动测试
4. 回归测试
5. 压力测试
6. ...

JUnit : 一个Java语言的单元测试框架
import static org.junit.Assert.*  //导入Assert类的所有静态方法

----
### 高级文本处理

Java 字符编码
- 字符: 0 ,a,我,@ ... 自然认知中字符是不能分割的.但是计算机存储可能占用多个基本内存
- 计算机只认识 0 1
- ASCII 码,奠定了计算机**编码**基础 一个btye 最多256个字符
- 扩展编码(加字节) IS8859 GB2132(中文) Big5 
- Unicode (字符集) 



XML 解析 
- DAM 方法: 以树结构全部加载到内存. 速度慢,资源消耗多.可以方便进行数据处理
- SAX 方法: 采用事件/流模型 速度更快更轻量 ,但是很难同时访问多处数据,并且不难访问已经流过的数据
- Stax : Java6推出,是拉模型,因为SAX是推模型,每个节点都会推过来,包括不需要的. Stax是优化,拉模型可以只拉去自己感兴趣的节点.

Json简介及解析
- JavaScript Object Notation JS对象表示法
- 类似 XML 更小 更快 更易解析
- 最早用于js 最后推广到全语言 因此独立于编程语言
- {K:V,K:V,K:V}
- [{},{},{}]

解析方式,三方api
JSON 官方 org.json  原生解析api, 过于复杂的功能不好实现. 已经集成到 android.jar
GSON 谷歌推出的解析方法 基于反射 功能强大
Jackson 号称最快解析api

JSON 更简短,方便传递. 但是会丢失顺序性


----
### 高级文本处理(续)


图形图像基础概念
>图形: Graph 矢量图,集合特性比如 点 直线 弧线
>图像: Image 由像素点构成 格式 jpg png svg gif 等 颜色 RGB

条形码和二维码
>条形码 长度不等的黑条和空白,按照一定的编码规则排列 一般30个字符以内
>二维码 几何图形在二维平面排列 可以有数字 字母 汉字 图片等 可以存储几百b到几十kb字符 
>有一定的抗损性

Zxing(Zebra Crossing)
- Google 出品 生成和解析
- 支持1d 2d
- 主要类 BitMatrix(位图矩阵) MultiFormatWriter(位图编写器) MatrixToImageWriter(写入图片)
- 
  

Docx简介及解析

- docx解析
  
- doxcx生成(完全生成,模板加部分生产:套打)
>处理的第三方库 Jacob, COM4J POI,docx4J等
> POI 是Apache出品,处理office套件. 纯Java工具包

表格文件简介

- xls/slsx 文件 (Microsoft Excel)
- CSV 文件,以逗号隔开数据.存储文本数据
- 数据
  - sheet
    - 行
    - 列
      - 单元格
第三方包来实现解析和生成
- POI 
- COM4J
- Asopse (收费)

PDF 简介和解析
第三方包
- Apache PDFBox
- iText(收费)

----

### Java多线程和并发编程

>当前操作系统都是多任务OS
每个独立执行的任务就是一个**进程**
OS时间片很短(ns us) 对于单核CPU 多任务是串行执行的.多核CPU才真正可并行运行
多进程也有缺点: 太笨重,不好管理,不好切换

多线程的概念

- 一个程序可以包括多个子任务,可串/并行
- 每个子任务为一个线程
- 一个子任务阻塞,程序可以将CPU调度到另外一个线程.这样CPU还是保留在本程序中.而不是被调度到别的程序(进程中),这样,提高本程序获得CPU时间和利用率

多进程 vs 多线程

- 线程共享数据
- 线程通讯更高效
- 线程更轻量,更容易切换
- 多个线程更容易管理

Java 多线程创建

- java.lang.Thread
  - 继承Thread类,实现run方法

- java.lang.Runnable接口
  - 实现Runnable接口,实现run方法

启动

- start方法,会自动以新线程调用run方法
- 调用run方法,将变成**串行执行**,也就是顺序执行
- 同一个线程,多次start,会报错
- 多线程启动,启动先后顺序是随机的
- 线程无需关闭,run方法结束后自动关闭
- main 函数可能早于新线程结束,整个程序并不终止
- 整个程序终止,则必须所有线程终止,包括主线程

Thread vs Runnable

- Thread 占据了父类名额,不如Runnable方便
- Thread 类实现Runnable
- Runnable 启动时需要Thread类支持
- Runnable 更容易实现多线程中资源共享
- 结论: 建议实现Runnable接口来完成多线程

多线程信息共享

- 通过共享变量在多个线程中共享信息
  
  - static 变量(只会随着类加载一次),继承Thread类,new 多个线程类
  - 同一个Runnable类的成员变量,实现接口,不用static也可以开多线程
 

多线程信息共享问题

- 工作缓存副本
  - 线程里面数据是缓存副本数据,外部修改,不一定会随着改变,volatile修饰的变量可线程同步
- 关键步骤缺乏加锁限制
  - 互斥 只能同时有一个线程操作
  - 同步 必须按照顺序运行
  - 互斥是同步的一种特例



多线程管理

- 粗粒度 直接start 调用run,run方法结束线程结束 
- 细粒度 线程直接有同步协作
  - 等待
  - 通知/唤醒
  - 终止

线程状态

1. NEW 刚创建(new)
2. RUNNABLE 就绪态(start)
3. RUNNING 运行中(run)
4. BLOCK 阻塞(sleep 时间到了自动醒来,wait 等带另一个线程唤醒,join 等待另一个线程结束, interrupt 默认是false,发送中断信号(调用了interrupt方法),后变为true.这里注意调用interrupt有可能导致异常,例如sleep时调用会抛异常 )
5. TERMINATED 结束


多线程死锁

- 每个线程互相持有别人需要的锁
- 预防死锁,对资源进行等级排序
  
守护(后台)线程

- 普通线程结束是run方法结束
- 守护线程结束是run方法结束或者main函数结束
- 守护线程永远不要访问资源,如文件数据库等

